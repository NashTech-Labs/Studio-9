package com.sentrana.umserver.utils

import javax.crypto.SecretKeyFactory
import javax.crypto.spec.PBEKeySpec

/**
 * Creates a new password hash from the specified salt, hash, and PBKDF2 iterations.
 *
 * @param salt The randomly generated salt.
 * @param hash The generated hash.
 * @param pbkdf2Iterations The number of iterations used within the PBKDF2 process.
 * Created by szhao on 3/10/14.
 */
class PasswordHash(val salt: Array[Byte], val hash: Array[Byte], val pbkdf2Iterations: Int) {
  import PasswordHash._

  /**
   * Validates a password against this hash.
   *
   * @param password The password to check.
   * @return True if the password is correct; false otherwise.
   */
  def checkPassword(password: String): Boolean = {
    val testHash: Array[Byte] = computeHash(password, salt, pbkdf2Iterations, hash.length)
    slowEquals(hash, testHash)
  }

  /**
   * Serializes this hash to a base-64 string.  This can later be recovered through the Parse() method.
   * seealso PasswordHash.parse()
   *
   * @return A base-64 representation of the entire hash.
   */
  def toBase64String: String = {
    Seq(pbkdf2Iterations.toHexString, toBase64(salt), toBase64(hash)).mkString(separator.toString)
  }

  /**
   * Compares two byte arrays in length-constant time. This comparison
   * method is used so that password hashes cannot be extracted from
   * on-line systems using a timing attack and then attacked off-line.
   *
   * @param a The first byte array.
   * @param b The second byte array.
   * @return True if both byte arrays are equal; false otherwise.
   */
  def slowEquals(a: Array[Byte], b: Array[Byte]): Boolean = {
    var diff: Int = a.length ^ b.length
    for (i <- 0 until math.min(a.length, b.length) - 1)
      diff |= (a(i) ^ b(i))
    diff == 0
  }
}

object PasswordHash {
  val separator: Char = ':'

  /**
   * Parses a password hash from the given string, assuming it was generated by the
   * ToString() method.
   *
   * @param compositeHash A hash of a correct password.
   * @return An object representation of the hash.
   */
  def parse(compositeHash: String): PasswordHash = {
    val split = compositeHash.split(separator)

    val iterations = Integer.parseInt(split(0), 16)
    val salt = fromBase64(split(1))
    val hash = fromBase64(split(2))

    new PasswordHash(salt, hash, iterations)
  }

  /**
   * Creates a new hash for the given password.  This also generates a new random salt.
   * <p>
   * The optional parameters may be changed without breaking existing hashes.
   * </p>
   *
   * @param password The password to hash.
   * @param hashBytes The number of bytes to output; also the size of salt.
   * @param iterations The number of iterations to use within the PBKDF2 process.
   * @return
   */
  def create(password: String, hashBytes: Int = 24, iterations: Int = 10000): PasswordHash = {
    val salt = generateRandomSalt(hashBytes)
    val hash = computeHash(password, salt, iterations, hashBytes)

    new PasswordHash(salt, hash, iterations)
  }

  /**
   * Generates a random cryptographic salt with the specified number of bytes.
   *
   * @param saltBytes The number of bytes to use in the salt.
   * @return A random salt.
   */
  def generateRandomSalt(saltBytes: Int): Array[Byte] = {
    randomAlphanumericString(saltBytes).getBytes()
  }

  def randomString(alphabet: String)(n: Int): String =
    Stream.continually((new scala.util.Random).nextInt(alphabet.length)).map(alphabet).take(n).mkString

  def randomAlphanumericString(n: Int) =
    randomString("abcdefghijklmnopqrstuvwxyz0123456789")(n)

  /**
   * Computes the PBKDF2-SHA1 hash of a password.
   *
   * @param password The password to hash.
   * @param salt The salt.
   * @param iterations The PBKDF2 iteration count.
   * @param outputBytes The length of the hash to generate, in bytes.
   * @return A hash of the password.
   */
  def computeHash(password: String, salt: Array[Byte], iterations: Int, outputBytes: Int): Array[Byte] = {
    // Following is implementation from JDK
    val spec: PBEKeySpec = new PBEKeySpec(password.toCharArray, salt, iterations, outputBytes * 8)
    val skf: SecretKeyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1")
    skf.generateSecret(spec).getEncoded
  }

  def toBase64(bytes: Array[Byte]): String = {
    (new sun.misc.BASE64Encoder).encode(bytes)
  }

  def fromBase64(str: String): Array[Byte] = {
    (new sun.misc.BASE64Decoder).decodeBuffer(str)
  }
}
